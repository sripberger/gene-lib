<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const _ = require('lodash');
const boolChance = require('bool-chance');

/**
 * Gets a random chromosome index between zero and length.
 * @param {number} length - Length of the chromosome.
 * @returns {number} A random integer in [0, length]
 */
exports.getRandomIndex = function(length) {
	return _.random(0, length);
};

/**
 * Gets two random chromosome indices, a start and an end.
 * @param {number} length - Length of the chromosome.
 * @returns {Array&lt;number>} Contains two random integers in [0, length]. For
 *   convenience, the lesser of the two will always be the first.
 *
 */
exports.getRandomRange = function(length) {
	let [ a, b ] = _.times(2, () => exports.getRandomIndex(length));
	return (a &lt; b) ? [ a, b ] : [ b, a ];
};

/**
 * Gets an array of random chromosome indices.
 * @param {number} length - Length of the chromosome.
 * @param {boolean} [pick=false] - Set to true to pick a set number of possible
 *   indices based on the provided ratio.
 * @param {number} [ratio=0.5] - Probability of an individual index being
 *   selected, or ratio of possible indices that will be selected (rounded
 *   down).
 * @returns {Arrray&lt;number>} Contains a random set of integers in [0, length].
 */
exports.getRandomIndices = function(length, pick = false, ratio = 0.5) {
	let indices = _.range(length);
	if (_.isNumber(pick)) {
		ratio = pick;
		pick = false;
	}
	if (pick) return _.sampleSize(indices, Math.floor(length * ratio));
	return indices.filter(() => boolChance.get(ratio));
};

/**
 * Performs a single-point crossover between two arrays or strings.
 * @param {Array|String} left - Left parent.
 * @param {Array|String} right - Right parent.
 * @returns {Array&lt;Array|String>} -  Will contain two children, of the same
 *   type as `left`.
 */
exports.singlePointCrossover = function(left, right) {
	let point = exports.getRandomIndex(left.length);
	return simpleCrossover(left, right, (i) => i >= point);
};

/**
 * Performs a two-point crossover between two arrays or strings.
 * @param {Array|String} left - Left parent.
 * @param {Array|String} right - Right parent.
 * @returns {Array&lt;Array|String>} -  Will contain two children, of the same
 *   type as `left`.
 */
exports.twoPointCrossover = function(left, right) {
	let range = exports.getRandomRange(left.length);
	return simpleCrossover(left, right, (i) => _.inRange(i, ...range));
};

/**
 * Performs a uniform crossover between two arrays or strings.
 * @param {Array|String} left - Left parent.
 * @param {Array|String} right - Right parent.
 * @param {boolean} [pick=false] - Set to true to pick a set number of possible
 *   crossover indices based on the provided ratio.
 * @param {number} [ratio=0.5] - Probability of an individual index being
 *   selected for crossover, or ratio of possible indices that will be selected
 *   (rounded down).
 * @returns {Array&lt;Array|String>} -  Will contain two children, of the same
 *   type as `left`.
 */
exports.uniformCrossover = function(left, right, pick, ratio) {
	let indices = exports.getRandomIndices(left.length, pick, ratio);
	return simpleCrossover(left, right, (i) => _.includes(indices, i));
};

/**
 * Performs a partially-matched crossover between two arrays or strings. Note
 * that '===' is used for equality comparisons in this operation, so if your
 * parent arrays contain objects, make sure they're references to the same
 * objects.
 * @param {Array|String} left - Left parent.
 * @param {Array|String} right - Right parent.
 * @returns {Arrray&lt;Array|String>} - Will contain two children, of the same type
 *   as `left`.
 */
exports.pmx = function(left, right) {
	let range = exports.getRandomRange(left.length);
	let leftSlice = left.slice(...range);
	let rightSlice = right.slice(...range);
	let children = [ [], [] ];
	for (let i = 0; i &lt; left.length; i += 1) {
		if (_.inRange(i, ...range)) {
			// Copy items directly from opposite-side parent.
			children[0].push(right[i]);
			children[1].push(left[i]);
		} else {
			// Use relationship between slices to prevent repeats.
			children[0].push(resolvePmxItem(left[i], rightSlice, leftSlice));
			children[1].push(resolvePmxItem(right[i], leftSlice, rightSlice));
		}
	}
	return convertChildren(children, left);
};


/**
 * Internal helper function for ensuring crossover children are returned as the
 * same type as their parents.
 * @private
 * @param {Array} children - Array of children to potentially convert.
 * @param {Array|String} parent - Sample parent.
 * @returns {Array&lt;Array|String>} - If the sample parent is a string, will be an
 *   array of converted child strings. Otherwise, will be the `children`
 *   argument directly.
 */
function convertChildren(children, parent) {
	return (_.isString(parent)) ? children.map((c) => c.join('')) : children;
}

/**
 * Internal helper function for performing simple crossovers, such that
 * repetitions of values are allowed in the child sequences.
 * @private
 * @param {Array|String} left - Left parent.
 * @param {Array|String} right - Right parent.
 * @param {Function} shouldCrossover - Receives the index of an item. If true
 *   is returned, the items at that index will switch sides in the children.
 * @returns {Array&lt;Array|String>} - An array containing the two children, of
 *   the same time as `left`.
 */
function simpleCrossover(left, right, shouldCrossover) {
	let children = [ [], [] ];
	for (let i = 0; i &lt; left.length; i += 1) {
		if (shouldCrossover(i)) {
			// Copy items directly from opposite-side parent.
			children[0].push(right[i]);
			children[1].push(left[i]);
		} else {
			// Copy items directly from same-side parent.
			children[0].push(left[i]);
			children[1].push(right[i]);
		}
	}
	return convertChildren(children, left);
}

/**
 * Internal helper function for resolving a partially-matched crossover. Uses
 * the relationship between two crossover slices to prevent repeats in the
 * child sequence.
 * @private
 * @param {*} item - Item to resolve.
 * @param {Array} incomingSlice - Crossover slice that is being moved into this
 *   child.
 * @param {Array} outgoingSlice - Crossover slice that is being replaced by the
 *   incoming slice.
 * @returns {*} - An item which does not appear in the incomingCrossover but
 *   does appear in the outgoing crossover.
 */
function resolvePmxItem(item, incomingSlice, outgoingSlice) {
	while (_.includes(incomingSlice, item)) {
		item = outgoingSlice[incomingSlice.indexOf(item)];
	}
	return item;
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ArraySelector.html">ArraySelector</a></li><li><a href="CachingChromosome.html">CachingChromosome</a></li><li><a href="Chromosome.html">Chromosome</a></li><li><a href="RouletteSelector.html">RouletteSelector</a></li><li><a href="Selector.html">Selector</a></li><li><a href="TournamentSelector.html">TournamentSelector</a></li></ul><h3>Global</h3><ul><li><a href="global.html#getRandomIndex">getRandomIndex</a></li><li><a href="global.html#getRandomIndices">getRandomIndices</a></li><li><a href="global.html#getRandomRange">getRandomRange</a></li><li><a href="global.html#pmx">pmx</a></li><li><a href="global.html#registerSelector">registerSelector</a></li><li><a href="global.html#run">run</a></li><li><a href="global.html#runSync">runSync</a></li><li><a href="global.html#singlePointCrossover">singlePointCrossover</a></li><li><a href="global.html#twoPointCrossover">twoPointCrossover</a></li><li><a href="global.html#uniformCrossover">uniformCrossover</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Nov 16 2017 21:55:25 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
